# -*- coding: utf-8 -*-
import os
from genericpath import isdir
from os import mkdir
from os.path import split, abspath, join

from xicam.plugins.tomorex import tomopynames as tp


def write_tomopy_script(infile, outfile, metadata, options, parameters,
                        recon_indices, job_params, out_format, save_as=None):
    """
    Writes a tomopy reconstruction script

    :param infile: str, path to input dataset
    :param outfile: str, path to write recon output
    :param metadata: dict, dataset metadata
    :param options: ordered dict, tomopy options as found in tomopy_names
    :param parameters: dict, tomopy parameters as found in tomopy_names
    :param recon_indices: tuple, sinogram and projection indices
                                ([sstart, send, sstep], [pstart, pend, pstep])
    :param job_params: dict, job parameters
    :param out_format: str, format to write output
    :param save_as: str, path to save generated script

    :return: str, path to script (same as save_as if given)
    """

    if save_as is None:
        if not isdir('.tmp'):
            mkdir('.tmp')
        dataset = split(infile)[-1].split('.')[0]
        save_as = abspath(join('.tmp', 'tomopy_recon_' + dataset + '.py'))

    indent = ''
    sino_indices = tuple(recon_indices[0])
    proj_indices = tuple(recon_indices[1])

    f = open(save_as, mode='w')
    f.write('# -*- coding: utf-8 -*-\n')
    f.write('\"\"\"\nTomoPy reconstruction script generated by SPEW Client\"\"\"\n\n')
    f.write('import sys\n')
    f.write('import logging\n')
    f.write('logging.basicConfig(level=logging.INFO, stream=sys.stdout,'
            'format=\'%(message)s\')\n\n')  # %(asctime)s - %(levelname)s -
    f.write('import numpy as np\nimport tomopy\n\n')
    f.write('fname = \'{}\' \n'.format(infile))
    f.write('outname = \'{}\'\n'.format(outfile))
    nproj = (proj_indices[1] - proj_indices[0])/proj_indices[2]
    f.write('nproj = {0}\n'.format(nproj))
    f.write('pxsize = {0}\n'.format(float(metadata['pxsize'])/10.0))
    f.write('theta = tomopy.angles(nproj, 270, 90)\n\n')
    f.write('logging.info(\'Finding center of rotation...\')\n')
    _write_cor_routine(f, 'fname', options['cor'], parameters[options['cor']],
                       int(metadata['nangles']), int(metadata['nslices']))
    f.write('logging.info(\'Center of rotation detected: %d\', cor)\n')

    if job_params['nchunk'] > 1:
        f.write('start_sino, stop_sino = {0}, {1}\n'.format(sino_indices[0],
                                                            sino_indices[1]))
        f.write('chunks = {0}\n'.format(str(job_params['nchunk'])))
        f.write('sino_per_chunk = (stop_sino - start_sino)//chunks \n\n')
        f.write('for i in range(chunks): \n')
        f.write('    start, end = i*sino_per_chunk + start_sino, (i + 1)*'
                'sino_per_chunk + start_sino \n')
        indent = '    '
        sino_indices = '(start, end, {0})'.format(sino_indices[2])
        f.write('{0}logging.info(\'Reading sinograms %i to %i...\', start, end)\n'.format(indent))
    else:
        f.write('logging.info(\'Reading sinograms...\')\n')

    f.write('{0}tomo, flat, dark, floc = '
            'tomopy.read_als_832h5(fname, sino={1}, proj={2})\n'
            .format(indent, sino_indices, proj_indices))

    if options['ring'] == 'polar mean filter':  # Re-order OrderedDict
        options['ring'] = options.pop('ring')
        options['mask'] = options.pop('mask')

    for i, (func, option) in enumerate(options.iteritems()):
        if func == 'pad' and option:
            if parameters['pad']['npad'] is None:
                dim = 'tomo.shape[{0}]'.format(parameters['pad']['axis'])
                f.write('{0}npad = int(np.ceil(({1}*np.sqrt(2) - {1})/2))\n'.format(indent, dim))
                parameters['pad']['npad'] = 'npad'
            else:
                f.write('{0}npad = {1}\n'.format(indent, parameters['pad']['npad']))

        if func == 'norm' and options['norm'] != 'background intensity':
            rval, ival = 'tomo', 'tomo, flat, dark'
            if options['norm'] == 'nearest flats':
                ival += ', floc'
        elif func == 'cor':
            continue  # COR gets special treatment in _write_cor_routine
        elif func == 'recon':
            rval, ival = 'rec', 'tomo, theta'
        elif func == 'mask':
            rval, ival = 'rec', 'rec, 0'
        elif (func, option) == ('ring', 'polar mean filter'):
            rval, ival = 'rec', 'rec'
        else:
            rval, ival = 'tomo', 'tomo'

        if isinstance(option, bool):
            if option is True:
                write_func = tp.FUNC_NAMES[func]
                option = func
            elif isinstance(option, str) and option != 'none':
                write_func = tp.FUNC_NAMES[func]
            else:
                continue
        elif option == 'none':
                continue
        else:
            write_func = tp.FUNC_NAMES[option]

        line = '{0}{1} = tomopy.{2}({3}'.format(indent, rval, write_func, ival)

        for j, (param, value) in enumerate(parameters[option].iteritems()):
            if value is not None:
                line += ', {0}='.format(param)
                if isinstance(value, str) and value not in ('cor', 'cor + npad', 'npad'):
                    line += '\'{0}\''.format(value)
                else:
                    line += str(value)

        if write_func in tp.MULT_CPU_FUNCS and job_params['ncore'] is not None:
            line += ', ncore={0}'.format(job_params['ncore'])

        f.write('{0}logging.info(\'Doing {1} ({2}) function...\')\n'.format(indent, func, option))
        f.write(line + ')\n')

        if func == 'recon' and options['pad'] == True:
            f.write('{0}rec = rec[:, npad:-npad, npad:-npad]\n'.format(indent))

    f.write('{0}rec /= pxsize  # intensity values in cm^-1'.format(indent))
    f.write('\n')

    f.write('{0}logging.info(\'Writing reconstruction slices to %s\', outname)\n'.format(indent))
    if out_format == 'TIFF':
        line = '{0}tomopy.write_tiff_stack(rec, fname=outname'.format(indent)
        if job_params['nchunk'] > 1:
            line += ', start=start'
    elif out_format == 'BL832 HDF':
        #TODO implement this brosef
        line = '{0}tomopy.write_tiff_stack(rec, fname={1}'.format(indent, outfile)
        if job_params['nchunk'] > 1:
            line += ', start=start'
    elif out_format == 'Data-exchange':
        #TODO implement this brosef
        line = '{0}tomopy.write_tiff_stack(rec, fname={1}'.format(indent, outfile)
        if job_params['nchunk'] > 1:
            line += ', start=start'
    elif out_format == 'NumPy bin':
        line = 'tomopy.write_npy(rec, {0}'.format(outfile)

    f.write(line + ')\n')
    f.write('logging.info(\'Reconstruction of {} complete.\')\n\n'.format(os.path.split(infile)[-1]))
    f.close()

    return save_as


def _write_cor_routine(fobject, fname, option, parameters, nproj, nslices):
    if option == 'manual':
        fobject.write('cor = {0}\n'.format(parameters['value']))
        return
    elif option == 'Nelder-Mead' or option == 'Vo':
        sino = (nslices//2, nslices//2 + 1) if parameters['ind'] is None \
                else (parameters['ind'], parameters['ind'] + 1)
        fobject.write('sslice, flat, dark, floc = tomopy.read_als_832h5({0}, '
                      'sino={1})\n'.format(fname, str(sino)))
        fobject.write('sslice = tomopy.normalize(sslice, flat, dark)\n')
        ivars = 'sslice, theta' if option == 'Nelder-Mead' else 'sslice'
    elif option == 'phase correlation':
        fobject.write('first, last = 0, {0}\n'.format(nproj))
        fobject.write('projs, flat, dark, floc = tomopy.read_als_832h5({0}, '
                      'ind_tomo=(0, {1}))\n'.format(fname, nproj - 1))
        fobject.write('projs = tomopy.normalize(projs, flat, dark)\n')
        ivars = 'projs[0], projs[1]'

        line = 'cor = tomopy.{0}({1}'.format(tp.FUNC_NAMES[option], ivars)

    for j, (param, value) in enumerate(parameters.iteritems()):
        if value is not None:
            line += ', {0}={1}'.format(param, str(value))
    line += ')\n'
    fobject.write(line)


def write_slurm_wrapper(run_cmd, nersc_run_cmd, script_path, env_cmds, **slurm_kwargs):
    """

    :param run_cmd:
    :param nersc_run_cmd:
    :param script_path:
    :param env_cmds:
    :param slurm_kwargs:
    :return:
    """
    if not os.isdir('.tmp'):
        os.mkdir('.tmp')

    wrapper_name = 'BATCH_' + os.path.split(script_path)[-1].split('.')[0] + '.slurm'
    wrapper = open(wrapper_name, mode='w')
    wrapper.write('#!/bin/bash\n\n')
    for kw in slurm_kwargs:
        wrapper.write('#SBATCH {0} {1}\n'.format(kw, slurm_kwargs[kw]))
    for cmd in env_cmds:
        wrapper.write(cmd + '\n')
